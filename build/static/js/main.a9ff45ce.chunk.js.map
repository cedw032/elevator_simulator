{"version":3,"sources":["hooks/useAsyncState.js","utils/dispatcher.js","constants/elevatorEvents.js","models/elevator.js","constants/elevatorState.js","constants/direction.js","models/usageSimulator.js","hooks/useForceUpdate.js","components/TimeController.js","components/TestSettingsController.js","hooks/useForceUpdateOnEvents.js","components/FloorDisplay.js","components/ElevatorDisplay.js","App.js","serviceWorker.js","index.js"],"names":["state","provideDispatcher","eventTypes","listeners","reduce","dispatcher","eventType","on","listener","push","filter","current","dispatch","_len","arguments","length","params","Array","_key","forEach","apply","ELEVATOR_EVENTS","provideElevator","floorCount","elevatorState","openTime","moveTime","currentFloor","currentDirection","destinations","requests","openTimeout","floors","i","canChangeDirection","filterFloorsAhead","floor","destinationsAhead","map","request","shouldOpen","destinationsAtCurrentFloor","requestsAtCurrentFloor","requestsAlsoMatchingCurrentDirection","destination","direction","isOpen","moveToNextFloor","closeDoors","doorsClose","_provideDispatcher","addDestination","destinationAdded","requestElevator","elevatorRequested","elapseTime","requestFilter","doorsOpen","openDoors","floorChange","timeElapsed","forceOpenTimeout","setOpenTimeout","value","concat","isDestination","isRequested","provideUsageSimulator","elevator","unsubscribeElapsedTime","enabled","spawn","randomInteger","min","max","spread","Math","random","origin","slice","destinationEntered","cancelListener","elevatorDirection","skip","cancelTimeout","toggle","undefined","useForceUpdate","_useState","useState","update","Object","slicedToArray","useAsyncState","initial","forceUpdate","TimeController","_ref","_useAsyncState","_useAsyncState2","asyncAutoplay","setAutoplay","useEffect","startAutoplay","setTimeout","applyAutoplayTimestep","react_default","a","createElement","className","children","onClick","cx","TestSettingsController","usageSimulator","useForceUpdateOnEvents","subscribeMethods","unsubscribeMethods","subscribe","unsubscribe","FloorDisplay","ElevatorDisplay","key","App","components_TimeController","components_TestSettingsController","components_FloorDisplay","components_ElevatorDisplay","Boolean","window","location","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a9ff45ce.chunk.js","sourcesContent":["import {useState} from 'react';\nimport useForceUpdate from './useForceUpdate';\n\nlet state;\n\nconst useAsyncState = (initial) => {\n\n\tif (!state) state = {value: initial};\n\n\tconst forceUpdate = useForceUpdate();\n\n\tconst updateValue = (value) => {\n\t\tif (value !== state.value) {\n\t\t\tstate.value = value;\n\t\t\tforceUpdate();\n\t\t}\n\t};\n\n\treturn [state, updateValue];\n}\n\nexport default useAsyncState;","const provideDispatcher = eventTypes => {\n\n\tconst listeners = {};\n\n\treturn eventTypes.reduce((dispatcher, eventType) => {\n\t\tlisteners[eventType] = [];\n\n\t\tdispatcher.on[eventType] = listener => {\n\t\t\tlisteners[eventType].push(listener);\n\n\t\t\treturn () => {\n\t\t\t\tlisteners[eventType] = listeners[eventType].filter(\n\t\t\t\t\tcurrent => current !== listener\n\t\t\t\t);\n\t\t\t};\n\t\t};\n\n\t\tdispatcher.dispatch[eventType] = (...params) => {\n\t\t\tlisteners[eventType].forEach(listener => listener(...params));\n\t\t};\n\n\t\treturn dispatcher;\n\n\t}, {dispatch: {}, on: {}});\n\n}\n\nexport default provideDispatcher;","const ELEVATOR_EVENTS = [\n\t'doorsOpen',\n\t'doorsClose',\n\t'floorChange',\n\t'timeElapsed',\n\t'elevatorRequested',\n\t'destinationAdded',\n];\n\nexport default ELEVATOR_EVENTS;","import provideDispatcher from '../utils/dispatcher';\n\n//////////////// CONSTANTS\nimport {UP, DOWN} from '../constants/direction';\nimport {STOPPED, OPEN, MOVING} from '../constants/elevatorState';\nimport ELEVATOR_EVENTS from '../constants/elevatorEvents';\n//////////////// CONSTANTS // END\n\nconst provideElevator = (floorCount) => {\n\n\t//////////////// INTERNAL STATE\n\tlet elevatorState = STOPPED;\n\tlet openTime = 0;\n\tlet moveTime = 0;\n\tlet currentFloor = 1;\n\tlet currentDirection = UP;\n\tlet destinations = [];\n\tlet requests = [];\n\n\tlet openTimeout = 0;\n\tlet timestepsBetweenFloors = 0;\n\n\tconst floors = [];\n\tfor (let i = 1; i <= floorCount; ++i) floors.push(i);\n\t///////////////// INTERNAL STATE // END\n\n\t///////////////// INTERNAL DERIVED STATE\n\tconst hasFloorToMoveTo = () => {\n\t\treturn !!(destinations.length + requests.length);\n\t};\n\n\tconst canChangeDirection = () => {\n\n\t\tconst filterFloorsAhead = floor => floor * currentDirection > currentFloor * currentDirection;\n\n\t\tconst destinationsAhead = destinations.filter(filterFloorsAhead);\n\n\t\tconst requestFloorsAhead = requests.map(\n\t\t\trequest => request.floor\n\t\t).filter(filterFloorsAhead);\n\n\t\treturn !(requestFloorsAhead.length + destinationsAhead.length);\n\t};\n\n\tconst shouldOpen = () => {\n\t\t\n\t\tif (destinationsAtCurrentFloor().length) return true;\n\n\t\tif (requestsAtCurrentFloor().length) {\n\t\t\tif (canChangeDirection()) return true;\n\t\t\tif (requestsAlsoMatchingCurrentDirection().length) return true;\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tconst destinationsAtCurrentFloor = () => destinations.filter(\n\t\tdestination => destination == currentFloor\n\t);\n\n\tconst requestsAtCurrentFloor = () => requests.filter(\n\t\trequest => request.floor == currentFloor\n\t);\n\n\tconst requestsAlsoMatchingCurrentDirection =  () => requestsAtCurrentFloor().filter(\n\t\trequest => request.direction == currentDirection\n\t);\n\n\tconst isOpen = () => elevatorState == OPEN;\n\n\t///////////////// INTERNAL DERIVED STATE // END\n\n\n\t///////////////// ACTIONS\n\tconst addDestination = floor => {\n\t\tdestinations.push(floor);\n\t\tif (elevatorState == OPEN) closeDoors();\n\t\tdispatch.destinationAdded();\n\t};\n\n\tconst requestElevator = (floor, direction) => {\n\t\trequests.push({floor, direction});\n\t\tdispatch.elevatorRequested();\n\t}\n\n\tconst moveToNextFloor = () => {\n\t\tmoveTime = 0;\n\t\televatorState = MOVING;\n\t};\n\n\tconst closeDoors = () => {\n\t\televatorState = STOPPED;\n\t\tdispatch.doorsClose();\n\t};\n\n\tconst stopElevator = () => elevatorState = STOPPED;\n\n\tconst openDoors = () => {\n\t\topenTime = 0;\n\n\t\tdestinations = destinations.filter(\n\t\t\tdestination => destination != currentFloor\n\t\t);\n\n\t\tconst requestFilter = canChangeDirection()\n\t\t\t? request => request.floor != currentFloor\n\t\t\t: request => request.floor != currentFloor || request.direction != currentDirection;\n\n\t\trequests = requests.filter(requestFilter);\n\n\t\televatorState = OPEN;\n\t\tdispatch.doorsOpen(currentFloor, currentDirection, canChangeDirection());\n\t};\n\n\tconst updateCurrentFloor = () => {\n\t\tcurrentFloor += currentDirection;\n\t\tdispatch.floorChange();\n\t};\n\n\tconst updateCurrentDirection = () => {\n\t\tif (canChangeDirection()) {\n\t\t\tcurrentDirection *= DOWN;\n\t\t}\n\t}\n\n\tconst forceOpenTimeout = () => {\n\t\tif (isOpen()) {\n\t\t\topenTime = openTimeout;\n\t\t}\n\t}\n\n\tconst elapseTime = () => {\n\t\tswitch (elevatorState) {\n\t\t\tcase STOPPED:\n\t\t\t\tif (shouldOpen()) {\n\t\t\t\t\topenDoors();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (hasFloorToMoveTo()) {\n\t\t\t\t\tupdateCurrentDirection();\n\t\t\t\t\tmoveToNextFloor();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase OPEN:\n\t\t\t\tif (openTime >= openTimeout) {\n\t\t\t\t\tcloseDoors();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++openTime;\n\t\t\t\tbreak;\n\n\t\t\tcase MOVING:\n\t\t\t\tif (moveTime >= timestepsBetweenFloors) {\n\t\t\t\t\tupdateCurrentFloor();\n\n\t\t\t\t\tif (shouldOpen()) {\n\t\t\t\t\t\tstopElevator();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmoveToNextFloor();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t++moveTime;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdispatch.timeElapsed();\n\t};\n\n\t///////////////// DISPATCHER\n\tconst {dispatch, on} = provideDispatcher(ELEVATOR_EVENTS);\n\t///////////////// DISPATCHER // END\n\n\t///////////////// PUBLIC INTERFACE\n\treturn {\n\t\taddDestination,\n\t\trequestElevator,\n\t\telapseTime,\n\t\tforceOpenTimeout,\n\n\t\tsetOpenTimeout: value => openTimeout = value,\n\n\t\tcurrentFloor: () => currentFloor,\n\t\tfloors: () => [...floors],\n\t\tisOpen,\n\n\t\tisDestination: floor => destinations.filter(\n\t\t\tdestination => destination == floor\n\t\t).length != 0,\n\n\t\tisRequested: (floor, direction) => requests.filter(\n\t\t\trequest => request.floor == floor && request.direction == direction\n\t\t).length != 0,\n\n\t\ton,\n\t};\n\t///////////////// PUBLIC INTERFACE // END\n\n}\n\nexport default provideElevator;","export const STOPPED = 0;\nexport const OPEN = 1;\nexport const MOVING = 2;","export const UP = 1;\nexport const DOWN = -1;","import {UP, DOWN} from '../constants/direction';\n\nconst provideUsageSimulator = elevator => {\n\n\tlet unsubscribeElapsedTime;\n\tlet spawnChance = 0.16;\n\n\tconst enabled = () => {\n\t\treturn !!unsubscribeElapsedTime;\n\t}\n\n\tconst toggle = () => {\n\n\t\tif (enabled()) {\n\t\t\tunsubscribeElapsedTime();\n\t\t\tunsubscribeElapsedTime = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tunsubscribeElapsedTime = elevator.on.timeElapsed(elapseTime);\n\n\t};\n\n\tconst spawn = () => {\n\t\tconst randomInteger = (min, max) => {\n\t\t\tconst spread = max - min + 1;\n\t\t\treturn Math.floor(spread * Math.random()) + min;\n\t\t}\n\n\t\tconst entering = 0;\n\t\tconst exiting = 1;\n\t\tconst otherTravel = 2;\n\n\t\tlet origin = 0;\n\t\tlet destination = 0;\n\n\t\tswitch (randomInteger(entering, otherTravel)) {\n\t\t\tcase entering:\n\t\t\t\torigin = elevator.floors[0];\n\t\t\t\tbreak;\n\n\t\t\tcase exiting:\n\t\t\t\tdestination = elevator.floors[0];\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (!origin) {\n\t\t\torigin = randomInteger(\n\t\t\t\televator.floors()[0], \n\t\t\t\televator.floors().slice(-1)\n\t\t\t);\n\t\t}\n\n\t\tif (!destination) {\n\t\t\tdestination = randomInteger(\n\t\t\t\televator.floors()[0], \n\t\t\t\televator.floors().slice(-1)\n\t\t\t);\n\t\t}\n\n\t\tif (origin === destination) return;\n\n\t\tconst direction = origin < destination ? UP : DOWN;\n\n\t\tlet destinationEntered = false;\n\n\t\tconst cancelListener = elevator.on.doorsOpen((floor, elevatorDirection, canChangeDirection) => {\n\t\t\tif (!destinationEntered && floor === origin) {\n\t\t\t\tif (canChangeDirection || elevatorDirection === direction) {\n\t\t\t\t\tlet skip = true;\n\t\t\t\t\tconst cancelTimeout = elevator.on.timeElapsed(() => {\n\t\t\t\t\t\tif (skip) {\n\t\t\t\t\t\t\tskip = false;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\televator.addDestination(destination);\t\n\t\t\t\t\t\tcancelTimeout();\t\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tdestinationEntered = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (destinationEntered && floor === destination) {\n\t\t\t\televator.forceOpenTimeout();\n\t\t\t\tcancelListener();\n\t\t\t}\n\t\t});\n\n\t\televator.requestElevator(origin, direction);\n\t\t\n\t}\n\n\tconst elapseTime = () => {\n\n\t\tif (Math.random() < spawnChance) {\n\t\t\tspawn();\n\t\t}\n\n\t};\n\n\treturn {\n\t\ttoggle,\n\t\tspawn,\n\t\tenabled,\n\t};\n\n}\n\nexport default provideUsageSimulator;","import {useState} from 'react';\n\nconst useForceUpdate = () => {\n\tconst [, update] = useState();\n\treturn () => update({});\n}\n\nexport default useForceUpdate;","import React, {useState, useEffect} from 'react';\nimport cx from 'classnames';\nimport useAsyncState from '../hooks/useAsyncState';\n\nconst AUTOPLAY_INTERVAL = 800;\nconst AUTOPLAY_OPEN_TIMEOUT = 5;\n\nconst TimeController = ({elevator}) => {\n\n\tconst [asyncAutoplay, setAutoplay] = useAsyncState(true);\n\n\tuseEffect(() => {\n\t\tif (asyncAutoplay.value) startAutoplay();\n\t}, []);\n\n\tconst applySingleTimestep = () => {\n\t\tsetAutoplay(false);\n\t\televator.elapseTime();\n\t}\n\n\tconst startAutoplay = () => {\n\t\tsetAutoplay(true);\n\t\televator.setOpenTimeout(AUTOPLAY_OPEN_TIMEOUT);\n\t\tsetTimeout(applyAutoplayTimestep);\n\t}\n\n\tconst applyAutoplayTimestep = () => {\n\t\tif (asyncAutoplay.value) {\n\t\t\televator.elapseTime();\n\t\t\tsetTimeout(applyAutoplayTimestep, AUTOPLAY_INTERVAL);\n\t\t\treturn;\n\t\t}\n\n\t\televator.setOpenTimeout(0);\n\t}\n\n\treturn (\n\t\t<div className='row'>\n\t\t\t<button \n\t\t\t\tchildren='|>'\n\t\t\t\tonClick={applySingleTimestep}/>\n\n\t\t\t<button \n\t\t\t\tchildren='>>'\n\t\t\t\tclassName={cx(asyncAutoplay.value && 'toggled')}\n\t\t\t\tonClick={startAutoplay}/>\n\t\t</div>\n\t);\n};\n\nexport default TimeController;","import React from 'react';\nimport cx from 'classnames';\nimport useForceUpdate from '../hooks/useForceUpdate';\n\n\nconst TestSettingsController = ({usageSimulator}) => {\n\n\tconst forceUpdate = useForceUpdate();\n\n\treturn (\n\t\t<div className='row'>\n\t\t\t<button \n\t\t\t\tonClick={() => {\n\t\t\t\t\tusageSimulator.spawn();\n\t\t\t\t\tforceUpdate();\n\t\t\t\t}}\n\t\t\t\tchildren='Random passenger'/>\n\t\t\t<button \n\t\t\t\tclassName={cx(usageSimulator.enabled() && 'toggled')}\n\t\t\t\tonClick={() => {\n\t\t\t\t\tusageSimulator.toggle();\n\t\t\t\t\tforceUpdate();\n\t\t\t\t}}\n\t\t\t\tchildren='Simulate usage'/>\n\t\t</div>\n\t);\n};\n\nexport default TestSettingsController;","import {useEffect} from 'react';\nimport useForceUpdate from './useForceUpdate';\n\nconst useForceUpdateOnEvents = (subscribeMethods) => {\n\tconst forceUpdate = useForceUpdate();\n\tuseEffect(() => {\n\t\tconst unsubscribeMethods = [];\n\t\tsubscribeMethods.forEach(\n\t\t\tsubscribe => unsubscribeMethods.push(subscribe(forceUpdate))\n\t\t);\n\n\t\treturn () => unsubscribeMethods.forEach(unsubscribe => unsubscribe());\n\t}, []);\n}\n\nexport default useForceUpdateOnEvents;","import React, {useEffect} from 'react';\nimport cx from 'classnames';\nimport {DOWN, UP} from '../constants/direction';\nimport useForceUpdateOnEvents from '../hooks/useForceUpdateOnEvents';\n\nconst FloorDisplay = ({floor, elevator}) => {\n\n\tuseForceUpdateOnEvents([\n\t\televator.on.floorChange,\n\t\televator.on.doorsOpen,\n\t\televator.on.doorsClose,\n\t\televator.on.elevatorRequested,\n\t]);\n\n\tconst isDoorOpen = () => elevator.currentFloor() == floor && elevator.isOpen()\n\n\tconst isAtThisFloor = () => elevator.currentFloor() == floor;\n\n\tconst isRequested = direction => elevator.isRequested(floor, direction)\n\n\tconst requestElevator = direction => () => elevator.requestElevator(floor, direction);\n\n\treturn (\n\t\t<div className={cx('row', 'floor-display', isAtThisFloor() && 'highlight')}>\n\t\t\t<div>\n\t\t\t\tFloor {floor}\n\t\t\t</div>\n\t\t\t\n\t\t\t<button \n\t\t\t\tclassName={cx(isRequested(DOWN) && 'toggled')}\n\t\t\t\tonClick={requestElevator(DOWN)}\n\t\t\t\tchildren='Down'/>\n\t\t\t\n\t\t\t<button \n\t\t\t\tclassName={cx(isRequested(UP) && 'toggled')}\n\t\t\t\tonClick={requestElevator(UP)}\n\t\t\t\tchildren='Up'/>\n\t\t\t\n\t\t\t{isDoorOpen()\n\t\t\t\t? <div className='highlight2'>Open</div>\n\t\t\t\t: <div className='hidden'>Open</div>\n\t\t\t}\n\t\t</div>\n\t);\n};\n\nexport default FloorDisplay;","import React, {useEffect} from 'react';\nimport cx from 'classnames';\nimport {DOWN, UP} from '../constants/direction';\nimport useForceUpdate from '../hooks/useForceUpdate';\nimport useForceUpdateOnEvents from '../hooks/useForceUpdateOnEvents';\n\nconst ElevatorDisplay = ({elevator}) => {\n\n\tuseForceUpdateOnEvents([\n\t\televator.on.doorsOpen,\n\t\televator.on.destinationAdded,\n\t]);\n\n\treturn (\n\t\t<div className='elevator-display'>\n\t\t\t{elevator.floors().map((floor) =>\n\t\t\t\t<button\n\t\t\t\t\tchildren={floor}\n\t\t\t\t\tkey={floor}\n\t\t\t\t\tclassName={\n\t\t\t\t\t\tcx(elevator.isDestination(floor) && 'toggled')\n\t\t\t\t\t}\n\t\t\t\t\tonClick={() => elevator.addDestination(floor)}/>\n\t\t\t)}\n\t\t</div>\n\t);\n};\n\nexport default ElevatorDisplay;","import React, {useState} from 'react';\nimport './App.css';\n\nimport provideElevator from './models/elevator';\nimport provideUsageSimulator from './models/usageSimulator';\n\nimport TimeController from './components/TimeController'\nimport TestSettingsController from './components/TestSettingsController'\nimport FloorDisplay from './components/FloorDisplay';\nimport ElevatorDisplay from './components/ElevatorDisplay';\n\nconst FLOOR_COUNT = 10;\n\nconst elevator = provideElevator(FLOOR_COUNT);\nconst usageSimulator = provideUsageSimulator(elevator);\n\nfunction App() {\n\n\treturn (\n\t\t<div className='app'>\n\t\t\t\n\t\t\t<div className='panel row top-bar'>\n\t\t\t\t<TimeController elevator={elevator}/>\n\t\t\t\t<TestSettingsController usageSimulator={usageSimulator}/>\n\t\t\t</div>\n\n\t\t\t<div className='row'>\n\t\t\t\t<div className='floor-bank panel'>\n\t\t\t\t\t{elevator.floors().map(floor =>\n\t\t\t\t\t\t<FloorDisplay \n\t\t\t\t\t\t\tfloor={floor}\n\t\t\t\t\t\t\televator={elevator}\n\t\t\t\t\t\t\tkey={floor}/>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t\t<ElevatorDisplay elevator={elevator}/>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}